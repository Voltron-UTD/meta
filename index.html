<html>
<head>
<title>Information for getting started</title>
</head>
<body>
<p><em>Project Voltron</em></p>
<h1 id="information-for-getting-started">Information for getting started</h1>
<hr />
<h2 id="hardware">Hardware</h2>
<p>Our current system includes:</p>
<ul>
<li>Polaris GEM e6
<ul>
<li>This is the car (Golf cart? Let&rsquo;s call it a car. It has a license plate.)</li>
<li>It&rsquo;s totally electric, with a battery bank in the rear &ldquo;trunk&rdquo;. I believe it has a small secondary battery for when the car isn&rsquo;t switched on, but I&rsquo;m not certain.</li>
<li><a href="https://gem.polaris.com/en-us/e6/specs/">Specs</a></li>
</ul>
</li>
<li>Nvidia Jetson TX2
<ul>
<li>This is the car&rsquo;s embedded, on-board computer.</li>
<li>It&rsquo;s meant for GPU-accelerated computing while also consuming little power and space. It&rsquo;s not nearly as powerful as a gaming PC, but the module itself is the size of a credit card, so what can you expect?</li>
<li>The TX2 uses an external SSD as a boot drive, since the built-in memory is so small.</li>
<li><a href="https://developer.nvidia.com/embedded/jetson-tx2">Specs</a></li>
</ul>
</li>
<li>2 Velodyne LIDAR pucks
<ul>
<li>I believe these are literally the &ldquo;Puck&rdquo; model (formerly &ldquo;VLP-16,&rdquo; but I&rsquo;m not certain.</li>
<li>One on front-right, one on rear-left</li>
</ul>
</li>
<li>GPS sensor
<ul>
<li>Model uncertain</li>
</ul>
</li>
<li>2 <a href="https://canable.io/">CANable Pro</a> CAN-to-USB interface chips</li>
<li>2 <a href="https://www.stereolabs.com/zed/">ZED stereo camera</a>
<ul>
<li>One above front windshield, one above rear windshield</li>
<li>Connected to Jetson via USB 3.0 hub</li>
</ul>
</li>
<li>Powered USB hub</li>
<li>Touchscreen display
<ul>
<li>Connected via HDMI to Jetson</li>
</ul>
</li>
<li>Wireless keyboard for debugging</li>
</ul>
<h2 id="software-tools">Software tools</h2>
<p>Think of our software as less like a stack and more like a  layered <a href="https://en.wikipedia.org/wiki/Matryoshka_doll">Matryoshka doll</a>.</p>
<h3 id="first-layer-operating-system">First layer: Operating System</h3>
<p>The operating system manages the low-level tasks of the computer. Windows, Mac OS X, Android, and iOS are all operating systems. Our car uses <strong>Ubuntu 18.04</strong>, which is a popular version of Linux. Using Linux gives us a lot of control over how the computer operates. Some of the software we use is not yet compatible with the latest long-term support release (Ubuntu 20.04), but we&rsquo;ll make that transition eventually.</p>
<h2 id="second-layer-container-environment">Second layer: Container environment</h2>
<p>Most of our code (ideally all of it) lives inside a Docker container. A Docker container is a sort of virtual environment that is designed to run exactly the same regardless of what system it runs on. It&rsquo;s not quite as full-featured as a virtual machine (VM), but it&rsquo;s a lot faster.</p>
<p>A running Docker instance can contain multiple containers, all running at the same time. We do this.</p>
<p>Our Docker environment is actually wrapped in &ldquo;ADE,&rdquo; which stands for Awesome Development Environment (I did not name it). ADE is a tool developed for Autoware (we&rsquo;ll come to that) that simplifies Docker a good bit. Anyway most of Docker is beyond me!</p>
<h2 id="third-layer-ros">Third layer: ROS</h2>
<p>Inside the Docker environment is a beautiful framework called the Robot Operating System. Its biggest job is to manage and distribute all the information between the many parts of our system. Our version of ROS, ROS2 Dashing, is part of a major rebuild of ROS that&rsquo;s still taking place (hence the &ldquo;2&rdquo;).</p>
<p>ROS contains many other useful tools, like the RViz data visualizer. Most open-source robotics software either supports or outright depends on ROS. It&rsquo;s the biggest software project that you&rsquo;ve probably never heard of.</p>
<p>The best part about ROS is that all the code you use is modular and language-agnostic. A program written in C++ can easily understand the results of another program written in Python, or even sent through a web server in JSON. So programmers don&rsquo;t necessarily need to learn specific tools, simply the ones they&rsquo;re most comfortable with.</p>
<p>I highly recommend that you watch <a href="https://www.youtube.com/watch?v=FTA4Ia2vLS8">this crash-course video about ROS</a>. Once you understand ROS, I also encourage you to walk through the official <a href="https://index.ros.org/doc/ros2/Tutorials/Configuring-ROS2-Environment/">ROS2 tutorials</a> (you should probably install Ubuntu for this, though).</p>
<h2 id="fourth-layer-autoware.auto">Fourth layer: Autoware.Auto</h2>
<p>The <a href="https://www.autoware.org/">Autoware Foundation</a> is a collection of companies, non-profits, and a few universities that develops open-source tools for self-driving cars. Their crown jewel is <strong><a href="https://www.autoware.auto">Autoware.Auto</a></strong>. It&rsquo;s still very much a work in progress, and is a bit messy in places, but Autoware.Auto at the moment provides a number of useful tools, including:</p>
<ul>
<li>An implementation of the Normal Distribution Transform localization algorithm</li>
<li>A couple controllers for following steering curves</li>
<li>Some tools for handling coordinate transforms (physical reference frames for our software)</li>
<li>A lot more&hellip; it&rsquo;s still growing. Maybe we can contribute!</li>
</ul>
<p>Autoware.Auto exists as a Docker image, loaded through ADE. It depends on ROS2, and uses it heavily.</p>
<h2 id="final-layer-custom-code">Final layer: Custom code</h2>
<p>In many cases, it&rsquo;s useful to add code on top of Autoware.Auto without modifying it directly. That way we can still use the &ldquo;official&rdquo; releases of Autoware.Auto while still enjoying our secret sauce.</p>
<p>For example, Autoware.Auto includes an interface (called a &ldquo;bridge&rdquo;) with our driving simulator, LGSVL. But the bridge they provide is a bit funky: it misses lots of useful data from the simulator, like the speed reported by the vehicle&rsquo;s speedometer. I added some simple code that reports this missing data.<a id="fnref:1" href="#fn:1" class="footnote"><sup>1</sup></a></p>
<h2 id="other-pieces-lgsvl-and-dash">Other pieces: LGSVL and Dash</h2>
<p><strong>LGSVL</strong> is a realistic and feature-rich driving simulator developed by the formerly-named LG Silicon Valley Lab (hence the name). It simulates LIDAR data, GPS, stereo cameras, and the CAN bus. It has a good physics engine, NPCs, weather simulation, and more. It&rsquo;s so good, in fact, that the Autoware Foundation used it exclusively to develop their parking demonstration, only testing in the real world two weeks before the demo.</p>
<p>LGSVL publishes all its results directly into ROS2. We run it <em>outside</em> the Docker container.<a id="fnref:2" href="#fn:2" class="footnote"><sup>2</sup></a> We run our Docker environment in a privileged mode that allows it to share the local network of the host. This is how LGSVL can communicate with software running in the container.</p>
<p>I also wrote a very basic (almost trivial) program called <strong>Dash</strong>. It&rsquo;s a web application that can connect to ROS and display data from the system. Right now it only displays the steering, throttle, and brake values from the simulated vehicle. Later on, we&rsquo;ll likely want to extend this to create a full-featured web dashboard that could not only visualize data but send commands. Dash is written in Typescript using Angular.</p>
<hr />
<div class="footnotes">
<hr />
<ol>
<li id="fn:1">
<p>I put all this code in a separate ROS workspace called &ldquo;Luna.&rdquo; The Autoware.Auto workspace and the Luna workspace coexist quite nicely. You can change the name from Luna, by the way.<a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
</li>
<li id="fn:2">
<p>Some of Autoware&rsquo;s documentation will say to run a special version of LGSVL within the Docker container. This modified version is outdated, and it simply doesn&rsquo;t run as well as the latest version running outside of Docker. It also uses a custom bridge that doesn&rsquo;t work very well.<a href="#fnref:2" class="reversefootnote">&#8617;</a></p>
</li>
</ol>
</div>
</body>
</html>